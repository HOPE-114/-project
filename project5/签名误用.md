# 基于签名算法误用的poc验证
## 主要项：
1.单次签名中随机数 k 泄露 → 恢复私钥 d（leaking k）  
2.同一私钥重用相同 k（同一用户多次重用 k）→ 恢复私钥 d（reusing k）  
3.不同用户使用相同 k（跨用户复用相同 k）→ 互相恢复私钥 d（reusing k by different users）  
4.同一私钥同时用于 ECDSA 与 SM2 且复用同一 k（same d and k with ECDSA）→ 恢复 d  
5.验证步骤/实现中的不完整检查（例如未校验消息 M、未校验 r/s 范围、未校验曲线方程或点有效性）→ 可伪造或接受无效签名  
6.签名格式可变导致的可塑性（malleability：例如 (r, s) 和 (r, -s)）→ 区块链分叉/双花类问题  
7.预计算 ZA 与公钥不对应，或把 ZA 当作独立于公钥的输入导致验证绕过  
8.从签名中恢复公钥（recover public key from signature）被滥用（例如发送交易时省略公钥）带来的风险或误用场景   

## 漏洞推导及证明
### 签名随机数 k 泄露 —— 恢复私钥 d
问题描述：SM2 签名公式：Let e = H(ZA || M), 随机数 k ∈ [1, n-1], compute kG = (x1, y1)，r =(e + x1) mod n，s = (1 + d)^(-1) * (k - rd) mod n ,如果攻击者知道 k（例如被旁路泄露、侧信道、随机数生成器缺陷等），则可直接解出私钥 d。  
推导：从 s 的定义：s (1 + d) ≡ k - r d (mod n)展开：  
s + s d ≡ k - r d (mod n)  
把含 d 的项移到一边：  
s d + r d ≡ k - s (mod n)  
d (s + r) ≡ k - s (mod n)  
因此（若 s + r ≠ 0 mod n）：d ≡ (k - s) * (s + r)^{-1} (mod n)，所以知道 k、r、s 即可直接算出 d。  
poc验证：  
```python
from hashlib import sha256

n = int("8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3", 16)

def modinv(a, m):
    return pow(a, m-2, m)

k = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
r = 0x1111111111111111111111111111111111111111111111111111111111111111
s = 0x2222222222222222222222222222222222222222222222222222222222222222

denom = (s + r) % n
if denom == 0:
    raise Exception("s + r == 0 (mod n), cannot invert")
d = ((k - s) * modinv(denom, n)) % n
print("Recovered d =", hex(d))
```

<img width="1078" height="106" alt="image" src="https://github.com/user-attachments/assets/82278f7f-94fa-4ecf-85a7-0a71987b5ddd" />


### 同一私钥重用相同 k（同一用户多次重用 k）—— 恢复私钥 d
问题描述：当同一私钥 d 用相同的 k 对不同消息 M1、M2 签名时，会产生 (r1, s1) 与 (r2, s2)。可利用二者求解 d。  
推导：  
写两次签名的等式（i = 1,2）：s_i (1 + d) ≡ k - r_i d (mod n)  
从两式相减：  
s1 (1 + d) - s2 (1 + d) ≡ (k - r1 d) - (k - r2 d)  
(s1 - s2)(1 + d) ≡ (r2 - r1) d (mod n)  
展开左侧：(s1 - s2) + (s1 - s2)d ≡ (r2 - r1)d  
把 d 项合并：  
(s1 - s2) ≡ d (r2 - r1 - s1 + s2) (mod n)  
d ≡ (s1 - s2) * (r2 - r1 - s1 + s2)^{-1} (mod n)  
等价化简为公式：d = (s2 - s1) * (s1 - s2 + r1 - r2)^{-1} mod n  
poc验证：
```python
n = int("8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3", 16)

def modinv(a, m): return pow(a % m, m-2, m)

r1 = ...
s1 = ...
r2 = ...
s2 = ...

num = (s2 - s1) % n
den = (s1 - s2 + r1 - r2) % n
if den == 0:
    raise Exception("Denominator zero")
d = (num * modinv(den, n)) % n
print("Recovered d =", hex(d))
```

### 不同用户使用相同 k —— 互相恢复私钥 d
问题描述：如果 Alice 与 Bob 在不同私钥下，但不慎使用了相同 k（例如同一 RNG 实现错误或多用户设备共享 RNG 状态），攻击者可利用两者签名恢复每人私钥。  
推导：  
对 Alice 签名 (r1, s1)：  
s1 (1 + dA) ≡ k - r1 dA (mod n)  
对 Bob 签名 (r2, s2)：  
s2 (1 + dB) ≡ k - r2 dB (mod n)  
重用 k 意味 k 相同，消去 k：  
s1 (1 + dA) + r1 dA ≡ s2 (1 + dB) + r2 dB (mod n)  
以上可以解出 dA（或 dB）  
```python
n = int("...hex n ...", 16)
def modinv(a, m): return pow(a % m, m-2, m)

r1 = ...
s1 = ...
r2 = ...
s2 = ...


denom = (s1 + r1) % n
if denom == 0:
    raise Exception("...")
```

### 同一私钥和 k 同时用于 ECDSA 与 SM2
问题描述：当相同私钥 d 和同一随机数 k 被用于 ECDSA 与 SM2（例如在同一设备或库中混用两种签名方式）时，攻击者可通过两种签名的不同公式联立方程求解 d。  
推导：  
ECDSA:  
s1 = k^{-1} (e1 + r1 d) => d r1 = k s1 - e1 (mod n)  
SM2:  
s2 (1 + d) ≡ k - r2 d => d s2 + r2 d ≡ k - s2 => d (s2 + r2) ≡ k - s2  
用 ECDSA 方程消去 k：  
k ≡ (d r1 + e1) * s1^{-1}  
代入 SM2 方程并解 d，最终可得：  
d = (s1s2 - e1) * (r1 - s1s2 - s1*r2)^{-1} mod n  
```python
n = ...
def modinv(a,m): return pow(a % m, m-2, m)
r1 = ...
s1 = ...
e1 = ...
r2 = ...
s2 = ...

num = (s1 * s2 - e1) % n
den = (r1 - s1*s2 - s1*r2) % n
d = (num * modinv(den, n)) % n
print(hex(d))
```


