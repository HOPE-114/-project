# SM3 哈希算法实现与优化对比

## 算法概述

SM3 是中国国家密码管理局发布的密码杂凑算法标准，输出长度为 256 位。本项目实现了标准 SM3 算法和一个优化版本，通过对消息填充、扩展及迭代压缩等核心流程的不同处理逻辑，开展效率对比测试，助力开发者深入理解算法原理与优化思路。

## 核心实现

### 1. 常量定义

SM3 算法依赖固定的初始向量和轮常数表，作为哈希计算的基础参数，保障算法执行的规范性与一致性。
￼

```cpp
const uint32_t IV[8] = {
    0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600,
    0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E
};  // 初始向量，作为哈希计算的初始状态 
const uint32_t T[64] = {
    0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519,
    0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A
};  // 常数表，压缩函数迭代时依据轮次选取对应值
```

​**代码说明**​：

* `IV[8]`：8 个 32 位无符号整数，作为哈希计算的初始状态，是 SM3 算法规定的固定起始参数。
* `T[64]`：64 个 32 位无符号整数，前 16 轮（索引 0 - 15）取值为 `0x79CC4519`，后 48 轮（索引 16 - 63）取值为 `0x7A879D8A`，用于压缩函数的轮运算，确保每一轮哈希计算的逻辑差异。

### 2. 辅助函数

SM3 算法依赖多个基础变换函数，用于实现数据的循环左移、置换与逻辑运算，是哈希计算的核心逻辑单元。

#### （1）循环左移函数 `ROTL32`
￼

```cpp
uint32_t ROTL32(uint32_t x, int n) {
    n &= 31;  // 确保移位位数在 0 - 31 范围内
    return (x << n) | (x >> (32 - n));
}
```

​**功能**​：对 32 位无符号整数 `x` 执行 `n` 位循环左移操作，为后续置换、压缩流程提供基础移位能力。
​**关键逻辑**​：通过 `n &= 31` 限制移位范围，避免无效移位；利用位运算 `(x << n) | (x >> (32 - n))` 实现循环左移。

#### （2）置换函数 `P0` 与 `P1`
￼

```cpp
uint32_t P0(uint32_t x) {
    return x ^ ROTL32(x, 9) ^ ROTL32(x, 17);
}

uint32_t P1(uint32_t x) {
    return x ^ ROTL32(x, 15) ^ ROTL32(x, 23);
}
```

​**功能**​：通过循环左移与异或操作，对输入数据进行置换变换，增强哈希结果的混淆度，是 SM3 算法的关键非线性变换环节。
​**逻辑差异**​：`P0` 和 `P1` 的循环左移位数不同（`P0` 为 9 和 17，`P1` 为 15 和 23 ），适配算法不同阶段的需求。

#### （3）逻辑函数 `FF` 与 `GG`
￼

```cpp
uint32_t FF(uint32_t x, uint32_t y, uint32_t z, int j) {
    if (j < 16) return x ^ y ^ z;
    else return (x & y) | (x & z) | (y & z);
}

uint32_t GG(uint32_t x, uint32_t y, uint32_t z, int j) {
    if (j < 16) return x ^ y ^ z;
    else return (x & y) | ((~x) & z);
}
```

​**功能**​：依据迭代轮次 `j` 切换逻辑运算规则，前 16 轮采用简单异或（`x ^ y ^ z` ），后续轮次使用更复杂的逻辑组合（`FF` 用与或运算，`GG` 用与和按位取反后的与运算 ），提升哈希结果的安全性。
​**设计意图**​：通过动态调整逻辑运算，增加哈希计算的复杂度，抵御密码分析攻击。

### 3. 标准 SM3 实现（`sm3_standard`）

完整遵循 SM3 算法规范，实现消息填充、扩展、迭代压缩与结果输出的全流程，是算法正确性的基准实现。

#### （1）消息填充
￼

```cpp
vector<uint8_t> m = msg;
m.push_back(0x80);  // 标记填充起始
while ((m.size() * 8) % 512 != 448) {
    m.push_back(0x00);  // 填充 0 补足长度
}
// 添加原始消息长度（大端序）
for (int i = 7; i >= 0; --i) {
    m.push_back((l >> (i * 8)) & 0xFF);
}
```

​**流程说明**​：

* 先附加 `0x80` 标记填充起始；
* 循环填充 `0x00`，使消息总长度满足 `448 mod 512`；
* 以大端序追加原始消息长度（单位：比特），确保消息格式符合 SM3 算法要求。

#### （2）消息扩展
￼

```cpp
uint32_t W[68], W1[64];
// 前 16 个 W 直接从消息分组转换
for (int j = 0; j < 16; ++j) {
    W[j] = (m[i + 4 * j] << 24) | (m[i + 4 * j + 1] << 16) |
           (m[i + 4 * j + 2] << 8) | m[i + 4 * j + 3];
}
// 后 52 个 W 通过迭代计算生成
for (int j = 16; j < 68; ++j) {
    W[j] = P1(W[j - 16] ^ W[j - 9] ^ ROTL32(W[j - 3], 15)) ^ 
           ROTL32(W[j - 13], 7) ^ W[j - 6];
}
// 生成 W1 数组
for (int j = 0; j < 64; ++j) {
    W1[j] = W[j] ^ W[j + 4];
}
```

​**核心逻辑**​：

* 前 16 个 `W` 直接由消息分组的字节数据转换为 32 位整数；
* 后 52 个 `W` 基于 `P1` 置换函数和循环左移生成，实现消息数据的扩展；
* `W1` 通过 `W` 数组的异或运算生成，为压缩函数提供额外扩展数据。

#### （3）迭代压缩
￼

```cpp
uint32_t A = V[0], B = V[1], C = V[2], D = V[3];
uint32_t E = V[4], F = V[5], G = V[6], H = V[7];
for (int j = 0; j < 64; ++j) {
    uint32_t SS1 = ROTL32(ROTL32(A, 12) + E + ROTL32(T[j], j), 7);
    uint32_t SS2 = SS1 ^ ROTL32(A, 12);
    uint32_t TT1 = FF(A, B, C, j) + D + SS2 + W1[j];
    uint32_t TT2 = GG(E, F, G, j) + H + SS1 + W[j];
    
    // 状态更新
    D = C; C = ROTL32(B, 9); B = A; A = TT1;
    H = G; G = ROTL32(F, 19); F = E; E = P0(TT2);
}
```

​**流程说明**​：

* 初始化状态寄存器 `A - H` 为当前分组的初始哈希值；
* 64 轮循环中，依次计算 `SS1`、`SS2`、`TT1`、`TT2`，并更新状态寄存器；
* 每一轮依赖辅助函数（`ROTL32`、`FF`、`GG`、`P0` 等）和扩展数据（`W`、`W1`、`T` ），逐步压缩消息分组。

#### （4）结果输出



```cpp
vector<uint8_t> digest(32);
for (int i = 0; i < 8; ++i) {
    digest[4 * i] = (V[i] >> 24) & 0xFF;
    digest[4 * i + 1] = (V[i] >> 16) & 0xFF;
    digest[4 * i + 2] = (V[i] >> 8) & 0xFF;
    digest[4 * i + 3] = V[i] & 0xFF;
}
```

​**功能**​：将最终的状态寄存器值（`V[0] - V[7]` ）转换为 256 位（32 字节）的大端序哈希值，作为消息的最终哈希结果。

### 4. 优化版 SM3 实现（`sm3_optimized`）

在标准实现基础上，通过**减少内存访问**和**合并轮次运算**优化执行效率，核心逻辑与标准实现兼容，但执行速度更快。

#### （1）消息扩展优化
￼

```cpp
for (int j = 16; j < 68; ++j) {
    // 缓存常用值，减少数组重复访问
    const uint32_t w16 = W[j - 16];
    const uint32_t w9 = W[j - 9];
    const uint32_t w3 = ROTL32(W[j - 3], 15);
    const uint32_t w13 = ROTL32(W[j - 13], 7);
    const uint32_t w6 = W[j - 6];
    W[j] = P1(w16 ^ w9 ^ w3) ^ w13 ^ w6;
}
```

​**优化点**​：通过局部变量缓存 `W[j - 16]`、`W[j - 9]` 等常用值，减少数组索引访问次数，提升数据读取效率。

#### （2）迭代压缩优化



```cpp
// 宏定义合并 4 轮压缩操作
#define ROUND(j) \
    SS1 = ROTL32(ROTL32(A, 12) + E + ROTL32(T[j], j), 7); \
    SS2 = SS1 ^ ROTL32(A, 12); \
    TT1 = FF(A, B, C, j) + D + SS2 + W1[j]; \
    TT2 = GG(E, F, G, j) + H + SS1 + W[j]; \
    D = C; C = ROTL32(B, 9); B = A; A = TT1; \
    H = G; G = ROTL32(F, 19); F = E; E = P0(TT2);

// 批量处理 64 轮（每 4 轮一组）
for (int j = 0; j < 64; ) {
    uint32_t SS1, SS2, TT1, TT2;
    ROUND(j++);
    ROUND(j++);
    ROUND(j++);
    ROUND(j++);
}
#undef ROUND
```

​**优化点**​：

* 用宏定义 `ROUND` 合并 4 轮压缩操作，减少循环控制和状态置换的开销；
* 借助编译器宏展开特性，将多轮运算 “批量执行”，利用指令级并行提升效率。

### 5. 效率测试（`benchmark`）

通过对比标准实现与优化实现的执行耗时和吞吐量，验证优化效果，量化算法性能提升。
![image](/project4/结果.png)
